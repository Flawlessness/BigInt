#include "BigInt.h"

BigInt BigInt::convert_dec_to_bin_mod(BigInt decimal_number)
{
    BigInt binary_number(0), factor(1);
    decimal_number.sign = 1;
    while (decimal_number > BigInt(0))
    {
        binary_number += (decimal_number % BigInt(2)) * factor;
        factor *= 10;
        decimal_number /= 2;
    }
    return binary_number;
}

BigInt BigInt::convert_bin_to_dec_mod(BigInt binary_number)
{
    BigInt decimal_number(0), factor(1);
    binary_number.sign = 1;
    while (binary_number > BigInt(0))
    {
        decimal_number += (binary_number % BigInt(2)) * factor;
        factor *= 2;
        binary_number /= 10;
    }
    return decimal_number;
}

BigInt BigInt::plus_one(BigInt binary_number)
{
    binary_number = convert_bin_to_dec_mod(binary_number);
    binary_number++;
    binary_number = convert_dec_to_bin_mod(binary_number);
    return binary_number;
}

BigInt BigInt::Not(BigInt binary_number)
{
    int64_t vector_size = (int64_t) binary_number.number.size();
    vector_size--;
    for (int64_t i = vector_size; i >= 0; --i)
    {
        int32_t factor = 1;
        for (long long int j = 0; j < size_num_digit; ++j)
        {
            if ((binary_number.number[i] % (factor * 10)) / factor == 1)
                binary_number.number[i] -= factor;
            else
                binary_number.number[i] += factor;
            factor *= 10;
        }
    }
    return binary_number;
}

BigInt::BigInt()
{
    number.push_back(0);
}

BigInt::BigInt(int32_t input_number)
{
    if (input_number < 0)
    {
        sign = -1;
        input_number *= sign;
    }
    if (input_number == 0)
        number.push_back(0);
    while (input_number > 0)
    {
        number.push_back(input_number % max_num_digit);
        input_number /= max_num_digit;
    }
}

BigInt::BigInt(std::string input_number)
{
    std::string valid_characters = "+-1234567890";
    if (input_number.find_first_not_of(valid_characters) != input_number.npos)
        throw std::invalid_argument("Invalid syntax.");
    if (input_number[0] == '-')
    {
        if ((input_number.length() == 2) && ((input_number[1]) == '0'))
            sign = 1;
        else
            sign = -1;
        input_number = input_number.substr(1).c_str();
    }
    if (input_number[0] == '+')
        input_number = input_number.substr(1).c_str();
    int64_t str_len = (int64_t) input_number.length();
    while (str_len > 0)
    {
        if (str_len >= 9)
        {
            str_len -= 9;
            number.push_back(std::stoi(input_number.substr(str_len, 9)));
        }
        else
        {
            number.push_back(std::stoi(input_number.substr(0, str_len)));
            break;
        }
    }
}

BigInt::BigInt(const BigInt &other)
{
    number = other.number;
    sign = other.sign;
}

BigInt &BigInt::operator=(const BigInt &other)
{
    number = other.number;
    sign = other.sign;
    return *this;
}

bool BigInt::operator==(const BigInt &other) const
{
    return (number == other.number) && (sign == other.sign);
}

bool BigInt::operator!=(const BigInt &other) const
{
    return !(*this == other);
}

bool BigInt::operator<(const BigInt &other) const
{
    if (sign != other.sign)
        return sign < other.sign;
    if (number.size() != other.number.size())
        return number.size() * sign < other.number.size() * sign;
    for (int64_t i = ((int64_t) number.size() - 1); i >= 0; --i)
        if (number[i] != other.number[i])
            return number[i] * sign < other.number[i] * sign;
    return false;
}

bool BigInt::operator>(const BigInt &other) const
{
    return (other < *this);
}

bool BigInt::operator<=(const BigInt &other) const
{
    return !(other < *this);
}

bool BigInt::operator>=(const BigInt &other) const
{
    return !(*this < other);
}

BigInt BigInt::operator+() const
{
    BigInt tmp = *this;
    return tmp;
}

BigInt BigInt::operator-() const
{
    BigInt tmp = *this;
    tmp.sign *= -1;
    if (*this == BigInt(0))
        tmp.sign = 1;
    return tmp;
}

BigInt &BigInt::operator++()
{
    *this += 1;
    return *this;
}

BigInt &BigInt::operator--()
{
    *this -= 1;
    return *this;
}

const BigInt BigInt::operator++(int32_t)
{
    BigInt tmp = *this;
    *this += 1;
    return tmp;
}

const BigInt BigInt::operator--(int32_t)
{
    BigInt tmp = *this;
    *this -= 1;
    return tmp;
}

BigInt &BigInt::operator+=(const BigInt &other)
{
    if (sign == other.sign)
    {
        if ((*this < other) && (sign == 1) || (*this > other) && (sign == -1))
        {
            int64_t size_vector_max = (int64_t) std::max(number.size(), other.number.size());
            number.resize(size_vector_max, 0);
            size_vector_max--;

            for (int64_t i = 0; i < size_vector_max; ++i)
            {
                number[i] += other.number[i];
                if (number[i] / max_num_digit != 0)
                {
                    number[i] %= max_num_digit;
                    number[i + 1]++;
                }
            }
            number[size_vector_max] += other.number[size_vector_max];
            if (number[size_vector_max] / max_num_digit != 0)
            {
                number[size_vector_max] %= max_num_digit;
                number.push_back(1);
            }
        }
        else
        {
            int64_t size_vector = (int64_t) other.number.size();
            size_vector--;
            for (int64_t i = 0; i < size_vector; ++i)
            {
                number[i] += other.number[i];
                if (number[i] / max_num_digit != 0)
                {
                    number[i] %= max_num_digit;
                    number[i + 1]++;
                }
            }
            number[size_vector] += other.number[size_vector];
            if (number[size_vector] / max_num_digit != 0)
            {
                number[size_vector] %= max_num_digit;
                number.push_back(1);
            }
        }
    }
    else
    {
        *this -= -other;
    }

    int64_t real_size = (int64_t) number.size(), size_vector = real_size - 1;
    number.resize(real_size);
    if (-*this == BigInt(0))
        sign = 1;
    return *this;
}

BigInt &BigInt::operator-=(const BigInt &other)
{
    if (sign == other.sign)
    {
        if ((*this < other) && (sign == 1) || (*this > other) && (sign == -1))
        {
            int64_t size_vector = (int64_t) other.number.size();
            number.resize(size_vector, 0);
            for (int64_t i = 0; i < size_vector; ++i)
            {
                number[i] = other.number[i] - number[i];
                if (number[i] < 0)
                {
                    number[i] += max_num_digit;
                    number[i + 1]++;
                }
            }
            sign *= -1;
        }
        else
        {
            int64_t size_vector = (int64_t) other.number.size();
            for (int64_t i = 0; i < size_vector; ++i)
            {
                number[i] -= other.number[i];
                if (number[i] < 0)
                {
                    number[i] += max_num_digit;
                    number[i + 1]--;
                }
            }
        }
    }
    else
    {
        *this += -other;
    }

    int64_t real_size = (int64_t) number.size(), size_vector = real_size - 1;
    while ((number[size_vector] == 0) && (real_size > 1))
    {
        real_size = size_vector;
        size_vector--;
    }
    number.resize(real_size);
    if (-*this == BigInt(0))
        sign = 1;
    return *this;
}

BigInt &BigInt::operator*=(const BigInt &other)
{
    int64_t this_size_vector = (int64_t) number.size(), other_size_vector = (int64_t) other.number.size();
    int64_t size_vector = this_size_vector + other_size_vector;
    std::vector<int64_t> tmp;
    tmp.resize(size_vector, 0);
    number.resize(size_vector, 0);
    for (int64_t i = 0; i < this_size_vector; ++i)
    {
        for (int64_t j = 0; j < other_size_vector; ++j)
        {
            tmp[i + j] += (int64_t) number[i] * (int64_t) other.number[j];
            if (tmp[i + j] / max_num_digit != 0)
            {
                tmp[i + j + 1] += tmp[i + j] / max_num_digit;
                tmp[i + j] %= max_num_digit;
            }
        }
    }
    for (int64_t i = 0; i < size_vector; ++i)
        number[i] = (int32_t) tmp[i];
    int64_t real_size = size_vector;
    size_vector--;
    while ((number[size_vector] == 0) && (real_size > 1))
    {
        real_size = size_vector;
        size_vector--;
    }
    number.resize(real_size);
    sign *= other.sign;
    if (-*this == BigInt(0))
        sign = 1;
    return *this;
}

BigInt &BigInt::operator/=(const BigInt &other)
{
    if (other == BigInt(0))
        throw std::invalid_argument("Division by zero.");
    int64_t this_vector_size = (int64_t) number.size();
    int8_t sign_tmp = sign * other.sign;
    BigInt result(0), current(0), other_copy(other);
    other_copy.sign = 1;
    result.number.resize(this_vector_size);
    for (int64_t i = (this_vector_size - 1); i >= 0; --i)
    {
        current *= max_num_digit;
        current += number[i];
        int32_t left = 0, right = max_num_digit, mid = 0, digit = 0;
        while (left <= right)
        {
            mid = (left + right) >> 1;
            BigInt tmp((int32_t) mid);
            tmp *= other_copy;
            if (tmp < current)
            {
                digit = mid;
                left = mid + 1;
            }
            else if (tmp > current)
            {
                right = mid - 1;
            }
            else
            {
                digit = mid;
                break;
            }

        }
        result.number[i] = digit;
        BigInt tmp(digit);
        tmp *= other_copy;
        current -= tmp;
    }

    int64_t real_size = this_vector_size;
    this_vector_size--;
    while ((result.number[this_vector_size] == 0) && (real_size > 1))
    {
        real_size = this_vector_size;
        this_vector_size--;
    }
    result.sign = sign * other.sign;
    result.number.resize(real_size);
    *this = result;
    if (-*this == BigInt(0))
        sign = 1;
    return *this;
}

BigInt &BigInt::operator%=(const BigInt &other)
{
    if (other == BigInt(0))
        throw std::invalid_argument("Division by zero.");
    int64_t this_vector_size = (int64_t) number.size();
    BigInt current(0), other_copy(other);
    other_copy.sign = 1;
    for (int64_t i = (this_vector_size - 1); i >= 0; --i)
    {
        current *= max_num_digit;
        current += number[i];
        int32_t left = 0, right = max_num_digit, mid = 0, digit = 0;
        while (left <= right)
        {
            mid = (left + right) >> 1;
            BigInt tmp((int32_t) mid);
            tmp *= other_copy;
            if (tmp < current)
            {
                digit = mid;
                left = mid + 1;
            }
            else if (tmp > current)
            {
                right = mid - 1;
            }
            else
            {
                digit = mid;
                break;
            }

        }
        BigInt tmp(digit);
        tmp *= other_copy;
        current -= tmp;
    }

    if ((sign == -1) && (current != BigInt(0)))
    {
        current -= other_copy;
        current.sign = 1;
    }
    *this = current;
    return *this;
}

BigInt &BigInt::operator^=(const BigInt &other)
{
    BigInt this_bin(0), other_bin(0), result(0);
    this_bin = convert_dec_to_bin_mod(*this);
    other_bin = convert_dec_to_bin_mod(other);
    int64_t this_size = (int64_t) this_bin.number.size(), other_size = (int64_t) other_bin.number.size();
    if (sign == -1)
    {
        this_bin = Not(this_bin);
        this_bin = plus_one(this_bin);
    }
    if (other.sign == -1)
    {
        other_bin = Not(other_bin);
        other_bin = plus_one(other_bin);
    }
    if (this_size < other_size)
    {
        if (sign == -1)
            this_bin.number.resize(other_size, 111111111);
        else
            this_bin.number.resize(other_size, 0);
    }
    else if (this_size > other_size)
    {
        if (other.sign == -1)
            other_bin.number.resize(this_size, 111111111);
        else
            other_bin.number.resize(this_size, 0);
    }
    int64_t max_size = std::max(this_size, other_size);
    result.number.resize(max_size, 0);
    for (int64_t i = 0; i < max_size; ++i)
    {
        int32_t factor = 1;
        for (int64_t j = 0; j < size_num_digit; ++j)
        {
            if (((this_bin.number[i] % (factor * 10)) / factor) != ((other_bin.number[i] % (factor * 10)) / factor))
                result.number[i] += factor;
            factor *= 10;
        }
    }
    if (sign != other.sign)
    {
        result = Not(result);
        result = plus_one(result);
    }
    result = convert_bin_to_dec_mod(result);
    if (sign != other.sign)
        result.sign = -1;
    *this = result;
    return *this;
}

BigInt &BigInt::operator&=(const BigInt &other)
{
    BigInt this_bin(0), other_bin(0), result(0);
    this_bin = convert_dec_to_bin_mod(*this);
    other_bin = convert_dec_to_bin_mod(other);
    int64_t this_size = (int64_t) this_bin.number.size(), other_size = (int64_t) other_bin.number.size();
    if (sign == -1)
    {
        this_bin = Not(this_bin);
        this_bin = plus_one(this_bin);
    }
    if (other.sign == -1)
    {
        other_bin = Not(other_bin);
        other_bin = plus_one(other_bin);
    }
    if (this_size < other_size)
    {
        if (sign == -1)
            this_bin.number.resize(other_size, 111111111);
        else
            this_bin.number.resize(other_size, 0);
    }
    else if (this_size > other_size)
    {
        if (other.sign == -1)
            other_bin.number.resize(this_size, 111111111);
        else
            other_bin.number.resize(this_size, 0);
    }
    int64_t max_size = std::max(this_size, other_size);
    result.number.resize(max_size, 0);
    for (int64_t i = 0; i < max_size; ++i)
    {
        int32_t factor = 1;
        for (int64_t j = 0; j < size_num_digit; ++j)
        {
            if (((this_bin.number[i] % (factor * 10)) / factor == 1) &&
                (other_bin.number[i] % (factor * 10)) / factor == 1)
                result.number[i] += factor;
            factor *= 10;
        }
    }
    if ((sign == -1) && (other.sign == -1))
    {
        result = Not(result);
        result = plus_one(result);
    }
    result = convert_bin_to_dec_mod(result);
    if ((sign == -1) && (other.sign == -1))
        result.sign = -1;
    *this = result;
    return *this;
}

BigInt &BigInt::operator|=(const BigInt &other)
{
    BigInt this_bin(0), other_bin(0), result(0);
    this_bin = convert_dec_to_bin_mod(*this);
    other_bin = convert_dec_to_bin_mod(other);
    int64_t this_size = (int64_t) this_bin.number.size(), other_size = (int64_t) other_bin.number.size();
    if (sign == -1)
    {
        this_bin = Not(this_bin);
        this_bin = plus_one(this_bin);
    }
    if (other.sign == -1)
    {
        other_bin = Not(other_bin);
        other_bin = plus_one(other_bin);
    }
    if (this_size < other_size)
    {
        if (sign == -1)
            this_bin.number.resize(other_size, 111111111);
        else
            this_bin.number.resize(other_size, 0);
    }
    else if (this_size > other_size)
    {
        if (other.sign == -1)
            other_bin.number.resize(this_size, 111111111);
        else
            other_bin.number.resize(this_size, 0);
    }
    int64_t max_size = std::max(this_size, other_size);
    result.number.resize(max_size, 0);
    for (int64_t i = 0; i < max_size; ++i)
    {
        int32_t factor = 1;
        for (int64_t j = 0; j < size_num_digit; ++j)
        {
            if (((this_bin.number[i] % (factor * 10)) / factor == 1) ||
                (other_bin.number[i] % (factor * 10)) / factor == 1)
                result.number[i] += factor;
            factor *= 10;
        }
    }
    if ((sign == -1) || (other.sign == -1))
    {
        result = Not(result);
        result = plus_one(result);
    }
    result = convert_bin_to_dec_mod(result);
    if ((sign == -1) || (other.sign == -1))
        result.sign = -1;
    *this = result;
    return *this;
}

BigInt BigInt::operator~() const
{
    BigInt bin_number(0);
    bin_number = convert_dec_to_bin_mod(*this);
    if (sign == -1)
    {
        bin_number = Not(bin_number);
        bin_number = plus_one(bin_number);
    }

    bin_number = Not(bin_number);

    if (sign == 1)
    {
        bin_number = Not(bin_number);
        bin_number = plus_one(bin_number);
    }

    bin_number = convert_bin_to_dec_mod(bin_number);
    bin_number.sign *= sign * (-1);
    return bin_number;
}

BigInt::operator int() const
{
    return sign * number[0];
}

BigInt::operator std::string() const
{
    std::string result;
    int64_t size = (int64_t) number.size();
    if (sign == -1)
        result.push_back('-');
    result += std::to_string(number[size - 1]);
    for (int64_t i = (size - 2); i >= 0; i--)
    {
        int64_t tmp = max_num_digit;
        for (int64_t j = 0; j < size_num_digit; ++j)
        {
            result += std::to_string((number[i] % tmp) / (tmp / 10));
            tmp /= 10;
        }
    }
    return result;
}

size_t BigInt::size() const
{
    return number.size() * 4;
}

BigInt::~BigInt()
{
    std::vector<int32_t>().swap(number);
}

BigInt operator+(const BigInt &a, const BigInt &b)
{
    BigInt tmp = a;
    tmp += b;
    return tmp;
}

BigInt operator-(const BigInt &a, const BigInt &b)
{
    BigInt tmp = a;
    tmp -= b;
    return tmp;
}

BigInt operator*(const BigInt &a, const BigInt &b)
{
    BigInt tmp = a;
    tmp *= b;
    return tmp;
}

BigInt operator/(const BigInt &a, const BigInt &b)
{
    BigInt tmp = a;
    tmp /= b;
    return tmp;
}

BigInt operator^(const BigInt &a, const BigInt &b)
{
    BigInt tmp = a;
    tmp ^= b;
    return tmp;
}

BigInt operator%(const BigInt &a, const BigInt &b)
{
    BigInt tmp = a;
    tmp %= b;
    return tmp;
}

BigInt operator&(const BigInt &a, const BigInt &b)
{
    BigInt tmp = a;
    tmp &= b;
    return tmp;
}

BigInt operator|(const BigInt &a, const BigInt &b)
{
    BigInt tmp = a;
    tmp |= b;
    return tmp;
}

std::ostream &operator<<(std::ostream &output, const BigInt &number)
{
    output << std::string(number);
    return output;
}

BigInt pow_bigint(BigInt &base, BigInt &power)
{
    if (power == BigInt(1))
        return base;
    BigInt tmp = base, i = 2, sqr_i = 4;
    base *= base;
    while (sqr_i <= power)
    {
        base *= base;
        i += i;
        sqr_i = 1;
        sqr_i *= i;
        sqr_i *= i;
    }
    for (; i < power; ++i)
        base *= tmp;
    return base;
}
